\begin{enumerate}
\item
警惕全局状态！

\item
忘记头文件的存在吧！
\end{enumerate}

\begin{myTip}{}
所有全局数据都应该是 constexpr
\end{myTip}

但全局的 constexpr 值是完全安全的。它们无法被修改，也不会造成“超距作用”。

如果你仍然在使用头文件，因为你还没有完全迁移到模块……

\begin{myTip}
所有全局的 constexpr 值都应该是 inline constexpr
\end{myTip}

\begin{myNotic}
在模块接口内部，constexpr 全局变量和 inline constexpr 全局变量都具有“外部链接”(external linkage)，因此我们不必为此担心。
\end{myNotic}

\filename{图62. static constexpr 示例}
\begin{cpp}
// my_library.hpp

// the object `dataset` will be duplicated in each .cpp
// file that includes this .hpp file
static constexpr auto dataset = make_data();
\end{cpp}

\filename{图63. inline constexpr 示例}
\begin{cpp}
// my_library.hpp

// the object `dataset` will exist once in the entire binary
inline constexpr auto dataset = make_data();
\end{cpp}





