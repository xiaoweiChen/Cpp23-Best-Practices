
与将代码去模板化(de-template-izing)的理由相同：这是异常处理例程遵循“不要重复自己”(Don't Repeat Yourself)原则的体现。

如果你需要处理多种不同类型的异常，你的代码可能看起来像这样：

\filename{图 113. 重复的异常处理。}
\begin{cpp}
void use_thing() {
  try {
    do_thing();
  } catch (const std::runtime_error &) {
    // handle it
  } catch (const std::exception &) {
    // handle it
  }
}

void use_other_thing() {
  try {
    do_other_thing();
  } catch (const std::runtime_error &) {
    // handle it
  } catch (const std::exception &) {
    // handle it
  }
}
\end{cpp}

一个“Lippincott函数”(以Lisa Lippincott命名)可以提供一个集中的异常处理例程。

\filename{图 114. 使用Lippincott函数消除异常处理的重复。}
\begin{cpp}
void handle_exception() {
  try {
    throw; // re-throw exception already in flight
  } catch (const std::runtime_error &) {
  } catch (const std::exception &) { }
}

void use_thing() {
  try {
    do_thing();
  } catch (...) {
    handle_exception();
  }
}

void use_other_thing() {
  try {
    do_other_thing();
  } catch (...) {
    handle_exception();
  }
}
\end{cpp}

这种技术并不新鲜——早在C++98之前就已经存在了。

\begin{myTip}{练习：你使用异常吗？}
如果你的项目使用了异常，那么很可能有空间可以简化和集中化你的错误处理例程。如果它不使用异常，那么你可能有其他类型的、被重复的错误处理例程。这些可以被简化吗？
\end{myTip}

\mySubsectionNoFile{57.1}{资源}

\begin{itemize}
\item
C++ 秘闻: 使用Lippincott函数进行集中式异常处理\footnote{\url{https://cppsecrets.blogspot.com/2013/12/using-lippincott-function-for.html}}

\item
C++ 周刊 第91集：使用Lippincott函数\footnote{\url{https://youtu.be/-amJL3AyADI}}
\end{itemize}

























