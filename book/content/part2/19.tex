Sanitizer(检测工具)是 C++ 的运行时分析工具，已集成在 GCC、Clang 和 MSVC 中。

如果你熟悉 Valgrind，那么这些 Sanitizer 提供了类似的功能，但速度比 Valgrind 快几个数量级。

可用的 Sanitizer 包括：

\begin{itemize}
\item
地址检测器(Address Sanitizer, ASan)

\item
未定义行为检测器(Undefined Behavior Sanitizer, UBSan)(关于未定义行为的更多内容将在后续章节介绍)

\item
线程检测器(Thread Sanitizer)

\item
数据流检测器(DataFlow Sanitizer，用于代码分析，而非查找缺陷)

\item
Lib Fuzzer(将在后续章节中介绍)
\end{itemize}

地址检测器(ASan)、未定义行为检测器(UBSan)和线程检测器(TSan)几乎能像“魔法”一样发现许多问题。在本书编写时，MSVC 对 Sanitizer 的支持正在逐步增强，而 GCC 和 Clang 已经提供了更成熟的支持。

John Regehr\footnote{\url{https://twitter.com/johnregehr}} 建议在开发过程中始终启用 ASan 和 UBSan。

当发生诸如越界内存访问等错误时，Sanitizer 会报告导致失败的具体条件，通常还会提供修复建议。

你可以通过类似以下命令启用地址和未定义行为检测器：

\begin{shell}
gcc -fsanitize=address,undefined 
\end{shell}

注意：Sanitizer 必须在项目构建的链接阶段也保持启用。

\begin{myNotic}{}
如何在 CMake 中使用 Sanitizer 的示例，可以在 C++ CMake 模板项目中找到\footnote{\url{https://github.com/cpp-best-practices/cmake_template}}
\end{myNotic}

请记住，要结合使用 Debug、Release、启用 Sanitizer 和禁用 Sanitizer 的构建方式，因为每种组合都可能暴露出不同的代码问题。

\begin{myTip}{练习：启用 Sanitizer}
\begin{itemize}
\item
研究如何为现有项目添加 Sanitizer 支持

\item
首先启用 ASan

\item
运行完整的测试套件，并调查发现的任何问题

\item
然后启用 UBSan

\item
再次运行完整测试套件
\end{itemize}

最终目标：在你的持续集成(CI)环境中，实现所有测试在启用 ASan 和 UBSan 的情况下顺利运行。
\end{myTip}

\begin{myTip}{练习：回退到 Valgrind 或 Dr. Memory}
如果你无法在当前环境中运行 ASan 和 UBSan，请尝试使用 Dr. Memory(支持 Windows/Linux/MacOS)或 Valgrind(支持 Linux/MacOS)来运行你的测试套件。
\end{myTip}

\mySubsectionNoFile{19.1}{资源}

\begin{itemize}
\item
MSVC 在 Windows 上支持 AddressSanitizer (ASan)\footnote{\url{https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-windows-with-msvc/}}

\item
Sanitizer 的源码和文档(GitHub)\footnote{\url{https://github.com/google/sanitizers}}

\item
Clang AddressSanitizer 文档\footnote{\url{https://clang.llvm.org/docs/AddressSanitizer.html}}

\item
Clang UndefinedBehaviorSanitizer 文档\footnote{\url{https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html}}
\end{itemize}