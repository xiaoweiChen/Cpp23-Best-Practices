C++17 引入了多态内存资源(Polymorphic Memory Resources, PMR)，这使得为标准容器添加自定义的分配策略变得非常简单。(遗憾的是，本书出版时，只有 GCC 和 MSVC 实现了这一 C++17 特性。)

我不建议在代码的各个地方都使用 PMR 或其他自定义分配策略。如果遵循本书中的其他规则，它们大多都不必要。

然而，我认为了解这些策略的存在并将其作为工具来限制堆的使用、获取可能需要的“最后一公里”性能，是一种最佳实践。

一个简单的例子是：

\filename{图43. 简单的 PMR 示例}

\begin{cpp}
import std;

int main() {
  // create stack space for data
  std::array<std::byte, 2048> stackBuf;

  // create monotonic_buffer_resource
  // * no data is freed until the owning buffer is destroyed
  std::pmr::monotonic_buffer_resource
  rsrc(stackBuf.data(), stackBuf.size());

  // all list nodes are created in the stackBuf storage
  // without using any dynamic allocation
  std::pmr::list<int> listOfThings{
    {1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10},
    &rsrc};
}
\end{cpp}

C++ 标准提供了几种不同的分配策略，可以分层并设置回退机制，并且很容易创建自己的策略。请查看相关资源，那里有一个关于此主题的全面的 C++ Weekly 播放列表。

\begin{myTip}{练习：PMR 如何融入项目？}
\begin{itemize}
\item
运行堆分析器，查找多余的堆分配。尽可能消除这些分配。

\item
在剩余的性能热点处尝试使用 PMR，看看它是否能提供帮助。
\end{itemize}
\end{myTip}

\begin{myTip}{练习：理解数据的“眨眼消失”(Winking Out)}
\begin{itemize}
\item
这是一个高级主题，不适合初学者。

\item
实际上可以将容器内的对象本身也创建在 PMR 资源内部。

\item
当这样做时，如果所有数据都由一个缓冲区资源拥有，就可以安全地避免调用所有析构函数。

\item
花些时间去理解这个概念\footnote{\url{https://github.com/lefticus/cpp_weekly/blob/master/PMR/performance_tests.cpp\#L259-L274}}
\end{itemize}
\end{myTip}

\mySubsectionNoFile{35.1}{资源}

\begin{itemize}
\item
C++ Weekly PMR 播放列表\footnote{\url{https://www.youtube.com/playlist?list=PLs3KjaCtOwSYXK0pxZZavDSF}}

\item
cppreference 上的编译器支持矩阵\footnote{\url{https://en.cppreference.com/w/cpp/compiler_support/17}}
\end{itemize}






