推理全局状态是困难的。
任何非常量的静态值或 std::shared\_ptr<> 都可能构成全局状态。我们无法确定谁可能会修改该值，也无法确定修改操作是否线程安全。
全局状态可能导致一些细微且难以追踪的 bug：一个函数修改了全局状态，而另一个函数可能依赖于该修改，或受到其负面影响。

\begin{myTip}{练习：全局状态，还剩下什么？}
如果您已完成之前的练习，那么您应该已经将所有静态变量设为 const。这非常好！您甚至可能已将其中一些设为 constexpr，这更加理想！
但您可能仍然残留着一些隐藏的全局状态。您是否有一个全局的单例日志器？该日志器是否会意外地在系统的不同模块之间共享状态？
其他单例呢？它们能否被消除？它们是否存在多线程初始化问题(例如，如果两个线程同时首次访问其中一个对象会发生什么)？
\end{myTip}

\mySubsectionNoFile{27.1}{资源}

\begin{itemize}
\item
《告别单例模式》- Peter Muldoon - Meeting C++ 2019\footnote{\url{https://youtu.be/f46jmm7r8Yg}}
\end{itemize}