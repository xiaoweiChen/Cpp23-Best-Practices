

应使用C++23模块(请忘记头文件的存在)，但这给确保库能被正确使用带来了新的挑战。如果你熟悉使用DLL和显式库导出(在MSVC中通常需要，如果选择不在任何操作系统的动态库中导出所有符号时也是必需的)，那么你可能见过如下代码：

\filename{图31. 简单的库导出示例}

\begin{cpp}
EXTERN_DLL_EXPORT int calculate(int input) {
  return input * 10;
}
\end{cpp}

如果你的导出不一致，就会遇到链接错误：

\filename{图32. 简单的库错误示例}

\begin{cpp}
// library.hpp
[[nodiscard]] constexpr int calculate(int input) {
  return input * 10;
}

EXTERN_DLL_EXPORT [[nodiscard]] constexpr int calculate(float input) {
  return input * 10.1;
}
\end{cpp}

\filename{图33. 简单的库错误使用示例}

\begin{cpp}
#include "library.hpp"
import std;

int main()
{
  // 这段代码能编译，但会产生链接时错误
  // (无论是静态链接还是运行时链接)
  // 因为float重载在编译时被找到
  // 但未被导出供库使用
  std::println("{}", calculate(3));
}
\end{cpp}

C++20模块给我们带来了类似但不同的、且可能更隐蔽的问题。

\filename{图34. 部分导出的重载集}

\begin{cpp}
// library.ixx
export module library;

// I'm only exporting the float overload
export [[nodiscard]] constexpr float calculate(float val) noexcept
{
  return val * 10.1f;
}

[[nodiscard]] constexpr int calculate(int val) noexcept
{
  return val * 10;
}
\end{cpp}

\filename{图35. 部分导出重载的使用}

\begin{cpp}
import library;
import std;

int main()
{
  // 这段代码能编译和链接，且不会发出任何警告，但会
  // 打印浮点数"30.3"而不是可能预期的整数"30"
  std::println("{}", calculate(3));
}
\end{cpp}






















